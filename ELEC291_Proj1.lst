                  2   $LIST
0000              4   
0000              5   org 0000H
0000 02042C       6      ljmp MyProgram
0003              7      
000B              8   org 0x000B
000B 020420       9            ljmp Timer0_ISR
000E             10   ; Timer/Counter 2 overflow interrupt vector
002B             11   org 0x002B
002B 0203DF      12            ljmp Timer2_ISR
002E             13   
002E             14   ; These register definitions needed by 'math32.inc'
0030             15   DSEG at 30H
0030             16   x:   ds 4
0034             17   y:   ds 4
0038             18   bcd: ds 5
003D             19   T2ov: ds 2 ; 16-bit timer 2 overflow (to measure the period of very slow signals)
003F             20   Seed: ds 4
0043             21   p1Score: ds 3
0046             22   p2Score: ds 3
0049             23   
0000             24   BSEG
0000             25   mf: dbit 1
0001             26   
                570   $LIST
                 28   $LIST
02C4             30   
02C4             31   cseg
02C4             32   ; These 'equ' must match the hardware wiring
02C4             33   LCD_RS equ P3.2
02C4             34   ;LCD_RW equ PX.X ; Not used in this code, connect the pin to GND
02C4             35   LCD_E  equ P3.3
02C4             36   LCD_D4 equ P3.4
02C4             37   LCD_D5 equ P3.5
02C4             38   LCD_D6 equ P3.6
02C4             39   LCD_D7 equ P3.7
02C4             40   
                 42   	$LIST
0370             44   
0370             45   CLK           EQU 22118400 ; Microcontroller system crystal frequency in Hz
0370             46   TIMER0_RATE   EQU 1000     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0370             47   TIMER0_RATE_HIGH EQU 4096
0370             48   TIMER0_RATE_LOW EQU 1000
0370             49   TIMER0_RELOAD EQU ((65536-(CLK/TIMER0_RATE)))
0370             50   TIMER0_RELOAD_HIGH EQU ((65536-(CLK/TIMER0_RATE_HIGH)))
0370             51   TIMER2_RATE   EQU 1000     ; 1000Hz, for a timer tick of 1ms
0370             52   ;Timer0_Rate used to change pitch
0370             53   TIMER2_RELOAD EQU ((65536-(CLK/TIMER2_RATE)))
0370             54   
0370             55   ;Music Frequencies
0370             56   TIMER0_RATE_A   EQU 440 
0370             57   
0370             58   
0370             59   cseg
0370             60   
0370             61   SOUND_OUT equ P1.1
0370             62   Player_One equ P2.1
0370             63   Player_Two equ P0.0
0370             64   
0370             65   
0370             66   ;                     1234567890123456    <- This helps determine the location of the counter
0370 50312020    67   Initial_Message:  db 'P1          P2', 0
     20202020
     20202020
     503200
037F 30302020    68   Overflow_Str:    db '00           00', 0
     20202020
     20202020
     20303000
038F 506C6179    69   Player_One_Text: db 'Player 1: ', 0
     65722031
     3A2000
039A 506C6179    70   Player_Two_Text: db 'Player 2: ',0
     65722032
     3A2000
03A5             71   
03A5             72   
03A5             73   ; Sends 10-digit BCD number in bcd to the LCD
03A5             74   Display_10_digit_BCD:
03A5 C000        75            push ar0
03A7 A83C        75            mov r0, bcd+4
03A9 12035A      75            lcall ?Display_BCD
03AC D000        75            pop ar0
03AE C000        76            push ar0
03B0 A83B        76            mov r0, bcd+3
03B2 12035A      76            lcall ?Display_BCD
03B5 D000        76            pop ar0
03B7 C000        77            push ar0
03B9 A83A        77            mov r0, bcd+2
03BB 12035A      77            lcall ?Display_BCD
03BE D000        77            pop ar0
03C0 C000        78            push ar0
03C2 A839        78            mov r0, bcd+1
03C4 12035A      78            lcall ?Display_BCD
03C7 D000        78            pop ar0
03C9 C000        79            push ar0
03CB A838        79            mov r0, bcd+0
03CD 12035A      79            lcall ?Display_BCD
03D0 D000        79            pop ar0
03D2 22          80            ret
03D3             81   
03D3             82   ;Initializes timer/counter 2 as a 16-bit timer
03D3             83   InitTimer2:
03D3 75C800      84            mov T2CON, #0 ; Stop timer/counter.  Set as timer (clock input is pin 22.1184MHz).
03D6             85            ; Set the reload value on overflow to zero (just in case is not zero)
03D6 75CB00      86            mov RCAP2H, #0
03D9 75CA00      87            mov RCAP2L, #0
03DC D2AD        88            setb ET2
03DE 22          89       ret
03DF             90   
03DF             91   Timer2_ISR:
03DF C2CF        92            clr TF2  ; Timer 2 doesn't clear TF2 automatically. Do it in ISR
03E1 C0E0        93            push acc
03E3 053D        94            inc T2ov+0
03E5 E53D        95            mov a, T2ov+0
03E7 7002        96            jnz Timer2_ISR_done
03E9 053E        97            inc T2ov+1
03EB             98   Timer2_ISR_done:
03EB D0E0        99            pop acc
03ED 32         100            reti
03EE            101   
03EE            102   Timer0_Init:
03EE E589       103            mov a, TMOD
03F0 54F0       104            anl a, #0xf0 ; Clear the bits for timer 0
03F2 4401       105            orl a, #0x01 ; Configure timer 0 as 16-timer
03F4 F589       106            mov TMOD, a
03F6 758CA9     107            mov TH0, #high(TIMER0_RELOAD)
03F9 758A9A     108            mov TL0, #low(TIMER0_RELOAD)
03FC            109            ; Set autoreload value
03FC 75F4A9     110            mov RH0, #high(TIMER0_RELOAD)
03FF 75F29A     111            mov RL0, #low(TIMER0_RELOAD)
0402            112            ; Enable the timer and interrupts
0402 D2A9       113       setb ET0  ; Enable timer 0 interrupt
0404 D28C       114       setb TR0  ; Start timer 0
0406 22         115            ret
0407            116            
0407            117   Timer0_HIGH_Init:
0407 E589       118            mov a, TMOD
0409 54F0       119            anl a, #0xf0 ; Clear the bits for timer 0
040B 4401       120            orl a, #0x01 ; Configure timer 0 as 16-timer
040D F589       121            mov TMOD, a
040F 758CEA     122            mov TH0, #high(TIMER0_RELOAD_HIGH)
0412 758AE8     123            mov TL0, #low(TIMER0_RELOAD_HIGH)
0415            124            ; Set autoreload value
0415 75F4EA     125            mov RH0, #high(TIMER0_RELOAD_HIGH)
0418 75F2E8     126            mov RL0, #low(TIMER0_RELOAD_HIGH)
041B            127            ; Enable the timer and interrupts
041B D2A9       128       setb ET0  ; Enable timer 0 interrupt
041D D28C       129       setb TR0  ; Start timer 0
041F 22         130            ret
0420            131   Timer0_ISR:
0420            132            ;clr TF0  ; According to the data sheet this is done for us already.
0420 B291       133            cpl SOUND_OUT ; Connect speaker to P1.1!
0422 32         134            reti
0423            135   
0423            136   ;---------------------------------;
0423            137   ; Hardware initialization         ;
0423            138   ;---------------------------------;
0423            139   Initialize_All:
0423 1203D3     140       lcall InitTimer2
0426 12031E     141       lcall LCD_4BIT ; Initialize LCD
0429 D2AF       142       setb EA
042B 22         143            ret
042C            144   
042C            145   ;---------------------------------;
042C            146   ; Main program loop               ;
042C            147   ;---------------------------------;
042C            148   MyProgram:
042C            149       ; Initialize the hardware:
042C 75817F     150       mov SP, #7FH
042F 120423     151       lcall Initialize_All
0432 D280       152       setb P0.0 ; Pin is used as input
0434            153       
0434 754300     154       mov p1Score, #0x00
0437 754600     155       mov p2Score, #0x00
043A            156       
043A C0E0       157            push acc
043C 7401       157            mov a, #1
043E 14         157            dec a
043F 120355     157            lcall ?Set_Cursor_1 ; Select column and row
0442 D0E0       157            pop acc
0444 C083       158            push dph
0446 C082       158            push dpl
0448 C0E0       158            push acc
044A 900370     158            mov dptr, #Initial_Message
044D 120348     158            lcall ?Send_Constant_String
0450 D0E0       158            pop acc
0452 D082       158            pop dpl
0454 D083       158            pop dph
0456            159       
0456 1203EE     160       lcall Timer0_Init
0459 1203D3     161       lcall InitTimer2
045C            162       
045C            163   forever:
045C            164       ; synchronize with rising edge of the signal applied to pin P0.0
045C C2CA       165       clr TR2 ; Stop timer 2
045E 75CC00     166       mov TL2, #0
0461 75CD00     167       mov TH2, #0
0464 753D00     168       mov T2ov+0, #0
0467 753E00     169       mov T2ov+1, #0
046A C2CF       170       clr TF2
046C D2CA       171       setb TR2
046E            172       
046E            173       ;lcall One_Cycle
046E            174       
046E 85CD3F     175       mov Seed+0, TH2
0471 754001     176       mov Seed+1, #0x01
0474 754187     177       mov Seed+2, #0x87
0477 85CC42     178       mov Seed+3, TL2
047A C2CA       179       clr TR2
047C            180        
047C            181   synch1:
047C E53E       182            mov a, T2ov+1
047E 54FE       183            anl a, #0xfe
0480 7034       184            jnz no_signal ; If the count is larger than 0x01ffffffff*45ns=1.16s, we assume there is no signal
0482 2080F7     185       jb P0.0, synch1
0485            186   synch2:    
0485 E53E       187            mov a, T2ov+1
0487 54FE       188            anl a, #0xfe
0489 702B       189            jnz no_signal
048B 3080F7     190       jnb P0.0, synch2
048E            191       ; Measure the period of the signal applied to pin P0.0
048E C2CA       192       clr TR2
0490 75CC00     193       mov TL2, #0
0493 75CD00     194       mov TH2, #0
0496 753D00     195       mov T2ov+0, #0
0499 753E00     196       mov T2ov+1, #0
049C C2CF       197       clr TF2
049E D2CA       198       setb TR2 ; Start timer 2
04A0            199   measure1:
04A0 E53E       200            mov a, T2ov+1
04A2 54FE       201            anl a, #0xfe
04A4 7010       202            jnz no_signal 
04A6 2080F7     203       jb P0.0, measure1
04A9            204   measure2:    
04A9 E53E       205            mov a, T2ov+1
04AB 54FE       206            anl a, #0xfe
04AD 7007       207            jnz no_signal
04AF 3080F7     208       jnb P0.0, measure2
04B2 C2CA       209       clr TR2 ; Stop timer 2, [T2ov+1, T2ov+0, TH2, TL2] * 45.21123ns is the period
04B4            210   
04B4 801F       211            sjmp skip_this
04B6            212   no_signal:       
04B6 C0E0       213            push acc
04B8 7401       213            mov a, #1
04BA 14         213            dec a
04BB 120353     213            lcall ?Set_Cursor_2 ; Select column and row
04BE D0E0       213            pop acc
04C0 C083       214            push dph
04C2 C082       214            push dpl
04C4 C0E0       214            push acc
04C6 90037F     214            mov dptr, #Overflow_Str
04C9 120348     214            lcall ?Send_Constant_String
04CC D0E0       214            pop acc
04CE D082       214            pop dpl
04D0 D083       214            pop dph
04D2 02045C     215       ljmp forever ; Repeat! 
04D5            216   skip_this:
04D5            217   
04D5            218            ; Make sure [T2ov+1, T2ov+2, TH2, TL2]!=0
04D5 E5CC       219            mov a, TL2
04D7 45CD       220            orl a, TH2
04D9 453D       221            orl a, T2ov+0
04DB 453E       222            orl a, T2ov+1
04DD 60D7       223            jz no_signal
04DF            224            ; Using integer math, convert the period to frequency:
04DF 85CC30     225            mov x+0, TL2
04E2 85CD31     226            mov x+1, TH2
04E5 853D32     227            mov x+2, T2ov+0
04E8 853E33     228            mov x+3, T2ov+1
04EB 75342D     229            mov y+0, #low (45 % 0x10000) 
04EE 753500     229            mov y+1, #high(45 % 0x10000) 
04F1 753600     229            mov y+2, #low (45 / 0x10000) 
04F4 753700     229            mov y+3, #high(45 / 0x10000)  ; One clock pulse is 1/22.1184MHz=45.21123ns
04F7 1201A8     230            lcall mul32
04FA 753464     231            mov y+0, #low (100 % 0x10000) 
04FD 753500     231            mov y+1, #high(100 % 0x10000) 
0500 753600     231            mov y+2, #low (100 / 0x10000) 
0503 753700     231            mov y+3, #high(100 / 0x10000)  ;mult by 1.44 by mult 144/100
0506 120235     232            lcall div32
0509 753490     233            mov y+0, #low (144 % 0x10000) 
050C 753500     233            mov y+1, #high(144 % 0x10000) 
050F 753600     233            mov y+2, #low (144 / 0x10000) 
0512 753700     233            mov y+3, #high(144 / 0x10000)   
0515 1201A8     234            lcall mul32
0518 7534B0     235            mov y+0, #low (1200 % 0x10000) 
051B 753504     235            mov y+1, #high(1200 % 0x10000) 
051E 753600     235            mov y+2, #low (1200 / 0x10000) 
0521 753700     235            mov y+3, #high(1200 / 0x10000)  ;since i used 2 1k resistors
0524 120235     236            lcall div32
0527            237   
0527            238            
0527            239            ;comparing capacitance with 200 nF
0527            240            ;Set_Cursor(2, 1)
0527            241            ;lcall hex2bcd
0527            242            ;lcall Display_10_digit_BCD
0527 12074E     243            lcall One_Cycle
052A            244            
052A            245            
052A 02045C     246       ljmp forever ; Repeat! 
052D            247       
052D            248   Inc_Score:
052D 7534C8     249            mov y+0, #low (200 % 0x10000) 
0530 753500     249            mov y+1, #high(200 % 0x10000) 
0533 753600     249            mov y+2, #low (200 / 0x10000) 
0536 753700     249            mov y+3, #high(200 / 0x10000) 
0539 120152     250            lcall x_gt_y
053C            251            ;if the capacitance is greater than 200, mf will be set to 1
053C            252            
053C 200001     253            jb mf, Add_Score
053F 22         254            ret
0540            255            
0540            256   Add_Score:
0540 0543       257            inc p1Score
0542 753043     258            mov x+0, #low (p1Score % 0x10000) 
0545 753100     258            mov x+1, #high(p1Score % 0x10000) 
0548 753200     258            mov x+2, #low (p1Score / 0x10000) 
054B 753300     258            mov x+3, #high(p1Score / 0x10000) 
054E C0E0       259            push acc
0550 7401       259            mov a, #1
0552 14         259            dec a
0553 120353     259            lcall ?Set_Cursor_2 ; Select column and row
0556 D0E0       259            pop acc
0558 12002E     260            lcall hex2bcd
055B 1203A5     261            lcall Display_10_digit_BCD
055E            262            
055E 02045C     263            ljmp forever            
0561            264   
0561            265   Bridge_Forever:
0561 02045C     266            ljmp forever
0564            267            
0564            268   ; pseudocode:
0564            269   ;        if P1 capacitance > 50 (Can replace this number), increment P1
0564            270   ;   if P2 capacitance > 50 , increment P2
0564            271   ;        lcall compareScores
0564            272   ;        ret
0564            273   
0564            274   Dec_Score:
0564 7534C8     275            mov y+0, #low (200 % 0x10000) 
0567 753500     275            mov y+1, #high(200 % 0x10000) 
056A 753600     275            mov y+2, #low (200 / 0x10000) 
056D 753700     275            mov y+3, #high(200 / 0x10000) 
0570 120152     276            lcall x_gt_y
0573            277            ;if the capacitance is greater than 200, mf will be set to 1
0573            278            
0573 200001     279            jb mf, Sub_Score
0576 22         280            ret
0577            281            
0577            282   Sub_Score:
0577 1543       283            dec p1Score
0579 753043     284            mov x+0, #low (p1Score % 0x10000) 
057C 753100     284            mov x+1, #high(p1Score % 0x10000) 
057F 753200     284            mov x+2, #low (p1Score / 0x10000) 
0582 753300     284            mov x+3, #high(p1Score / 0x10000) 
0585 C0E0       285            push acc
0587 7401       285            mov a, #1
0589 14         285            dec a
058A 120353     285            lcall ?Set_Cursor_2 ; Select column and row
058D D0E0       285            pop acc
058F 12002E     286            lcall hex2bcd
0592 1203A5     287            lcall Display_10_digit_BCD
0595            288            
0595 02045C     289            ljmp forever
0598            290   ; pseudocode:
0598            291   ;        if P1 capacitance > 50 (Can replace this number), decrement P1
0598            292   ;   if P2 capacitance > 50 , decrement P2
0598            293   ;        ret    
0598            294   
0598            295   Random: 
0598            296            ; Dont worry about this, it is just some math that is good enough to randomize numbers enough for our purposes
0598 853F30     297       mov x+0, Seed+0
059B 854031     298       mov x+1, Seed+1
059E 854132     299       mov x+2, Seed+2
05A1 854233     300       mov x+3, Seed+3
05A4 7534FD     301            mov y+0, #low (214013 % 0x10000) 
05A7 753543     301            mov y+1, #high(214013 % 0x10000) 
05AA 753603     301            mov y+2, #low (214013 / 0x10000) 
05AD 753700     301            mov y+3, #high(214013 / 0x10000) 
05B0 1201A8     302       lcall mul32
05B3 7534C3     303            mov y+0, #low (2531011 % 0x10000) 
05B6 75359E     303            mov y+1, #high(2531011 % 0x10000) 
05B9 753626     303            mov y+2, #low (2531011 / 0x10000) 
05BC 753700     303            mov y+3, #high(2531011 / 0x10000) 
05BF 1200F3     304       lcall add32
05C2 85303F     305       mov Seed+0, x+0
05C5 853140     306       mov Seed+1, x+1
05C8 853241     307       mov Seed+2, x+2
05CB 853342     308       mov Seed+3, x+3
05CE 22         309       ret
05CF            310       
05CF            311   Wait_Random_Time:
05CF C002       312            push AR2
05D1 AA3F       312            mov R2, Seed+0
05D3 1202CF     312            lcall ?Wait_Milli_Seconds
05D6 D002       312            pop AR2
05D8 120564     313            lcall Dec_Score
05DB C002       314            push AR2
05DD AA40       314            mov R2, Seed+1
05DF 1202CF     314            lcall ?Wait_Milli_Seconds
05E2 D002       314            pop AR2
05E4            315       ;Inc_Score ... so on in between each random wait time
05E4 120564     316       lcall Dec_Score
05E7 C002       317            push AR2
05E9 AA41       317            mov R2, Seed+2
05EB 1202CF     317            lcall ?Wait_Milli_Seconds
05EE D002       317            pop AR2
05F0 120564     318       lcall Dec_Score
05F3 C002       319            push AR2
05F5 AA42       319            mov R2, Seed+3
05F7 1202CF     319            lcall ?Wait_Milli_Seconds
05FA D002       319            pop AR2
05FC 120564     320       lcall Dec_Score
05FF C002       321            push AR2
0601 AA3F       321            mov R2, Seed+0
0603 1202CF     321            lcall ?Wait_Milli_Seconds
0606 D002       321            pop AR2
0608 120564     322       lcall Dec_Score
060B C002       323            push AR2
060D AA40       323            mov R2, Seed+1
060F 1202CF     323            lcall ?Wait_Milli_Seconds
0612 D002       323            pop AR2
0614 120564     324       lcall Dec_Score
0617 C002       325            push AR2
0619 AA41       325            mov R2, Seed+2
061B 1202CF     325            lcall ?Wait_Milli_Seconds
061E D002       325            pop AR2
0620 120564     326       lcall Dec_Score
0623 C002       327            push AR2
0625 AA42       327            mov R2, Seed+3
0627 1202CF     327            lcall ?Wait_Milli_Seconds
062A D002       327            pop AR2
062C 120564     328       lcall Dec_Score
062F C002       329            push AR2
0631 AA3F       329            mov R2, Seed+0
0633 1202CF     329            lcall ?Wait_Milli_Seconds
0636 D002       329            pop AR2
0638 120564     330       lcall Dec_Score
063B C002       331            push AR2
063D AA40       331            mov R2, Seed+1
063F 1202CF     331            lcall ?Wait_Milli_Seconds
0642 D002       331            pop AR2
0644 120564     332       lcall Dec_Score
0647 C002       333            push AR2
0649 AA41       333            mov R2, Seed+2
064B 1202CF     333            lcall ?Wait_Milli_Seconds
064E D002       333            pop AR2
0650 120564     334       lcall Dec_Score
0653 C002       335            push AR2
0655 AA42       335            mov R2, Seed+3
0657 1202CF     335            lcall ?Wait_Milli_Seconds
065A D002       335            pop AR2
065C 120564     336       lcall Dec_Score
065F C002       337            push AR2
0661 AA3F       337            mov R2, Seed+0
0663 1202CF     337            lcall ?Wait_Milli_Seconds
0666 D002       337            pop AR2
0668 120564     338            lcall Dec_Score
066B C002       339            push AR2
066D AA40       339            mov R2, Seed+1
066F 1202CF     339            lcall ?Wait_Milli_Seconds
0672 D002       339            pop AR2
0674            340       ;Inc_Score ... so on in between each random wait time
0674 120564     341       lcall Dec_Score
0677 C002       342            push AR2
0679 AA41       342            mov R2, Seed+2
067B 1202CF     342            lcall ?Wait_Milli_Seconds
067E D002       342            pop AR2
0680 120564     343       lcall Dec_Score
0683 C002       344            push AR2
0685 AA42       344            mov R2, Seed+3
0687 1202CF     344            lcall ?Wait_Milli_Seconds
068A D002       344            pop AR2
068C 120564     345       lcall Dec_Score
068F C002       346            push AR2
0691 AA3F       346            mov R2, Seed+0
0693 1202CF     346            lcall ?Wait_Milli_Seconds
0696 D002       346            pop AR2
0698 120564     347            lcall Dec_Score
069B C002       348            push AR2
069D AA40       348            mov R2, Seed+1
069F 1202CF     348            lcall ?Wait_Milli_Seconds
06A2 D002       348            pop AR2
06A4            349       ;Inc_Score ... so on in between each random wait time
06A4 120564     350       lcall Dec_Score
06A7 C002       351            push AR2
06A9 AA41       351            mov R2, Seed+2
06AB 1202CF     351            lcall ?Wait_Milli_Seconds
06AE D002       351            pop AR2
06B0 120564     352       lcall Dec_Score
06B3 C002       353            push AR2
06B5 AA42       353            mov R2, Seed+3
06B7 1202CF     353            lcall ?Wait_Milli_Seconds
06BA D002       353            pop AR2
06BC 120564     354       lcall Dec_Score
06BF C002       355            push AR2
06C1 AA3F       355            mov R2, Seed+0
06C3 1202CF     355            lcall ?Wait_Milli_Seconds
06C6 D002       355            pop AR2
06C8 120564     356            lcall Dec_Score
06CB C002       357            push AR2
06CD AA40       357            mov R2, Seed+1
06CF 1202CF     357            lcall ?Wait_Milli_Seconds
06D2 D002       357            pop AR2
06D4            358       ;Inc_Score ... so on in between each random wait time
06D4 120564     359       lcall Dec_Score
06D7 C002       360            push AR2
06D9 AA41       360            mov R2, Seed+2
06DB 1202CF     360            lcall ?Wait_Milli_Seconds
06DE D002       360            pop AR2
06E0 120564     361       lcall Dec_Score
06E3 C002       362            push AR2
06E5 AA42       362            mov R2, Seed+3
06E7 1202CF     362            lcall ?Wait_Milli_Seconds
06EA D002       362            pop AR2
06EC 120564     363       lcall Dec_Score
06EF 22         364       ret    
06F0            365       
06F0            366   Wait_Constant_Time:
06F0 C002       367            push AR2
06F2 7AFF       367            mov R2, #255
06F4 1202CF     367            lcall ?Wait_Milli_Seconds
06F7 D002       367            pop AR2
06F9 12052D     368            lcall Inc_Score
06FC C002       369            push AR2
06FE 7AFF       369            mov R2, #255
0700 1202CF     369            lcall ?Wait_Milli_Seconds
0703 D002       369            pop AR2
0705 12052D     370       lcall Inc_Score
0708 C002       371            push AR2
070A 7AFF       371            mov R2, #255
070C 1202CF     371            lcall ?Wait_Milli_Seconds
070F D002       371            pop AR2
0711 12052D     372       lcall Inc_Score
0714 C002       373            push AR2
0716 7AFF       373            mov R2, #255
0718 1202CF     373            lcall ?Wait_Milli_Seconds
071B D002       373            pop AR2
071D 12052D     374       lcall Inc_Score
0720 C002       375            push AR2
0722 7AFF       375            mov R2, #255
0724 1202CF     375            lcall ?Wait_Milli_Seconds
0727 D002       375            pop AR2
0729 12052D     376       lcall Inc_Score
072C C002       377            push AR2
072E 7AFF       377            mov R2, #255
0730 1202CF     377            lcall ?Wait_Milli_Seconds
0733 D002       377            pop AR2
0735 12052D     378       lcall Inc_Score
0738 C002       379            push AR2
073A 7AFF       379            mov R2, #255
073C 1202CF     379            lcall ?Wait_Milli_Seconds
073F D002       379            pop AR2
0741 12052D     380       lcall Inc_Score
0744 C002       381            push AR2
0746 7AFF       381            mov R2, #255
0748 1202CF     381            lcall ?Wait_Milli_Seconds
074B D002       381            pop AR2
074D 22         382       ret
074E            383       
074E            384   One_Cycle:
074E 1205CF     385            lcall Wait_Random_Time ; in here, we are continuously checking if someone slaps, if they do, we decrement
0751 120407     386       lcall Timer0_HIGH_Init
0754            387       ;Wait for slap, if slapped, increment score
0754 1206F0     388       lcall Wait_Constant_Time ; in here, we are continuously checking if someone slaps, if they do we increment
0757 1203EE     389       lcall Timer0_Init
075A            390       ;Wait for slap, if slapped, decrement score
075A 22         391       ret
075B            392       
075B            393   Compare_Scores:
075B            394   ;   if p1Score == 5 , ljmp P1_Wins
075B            395            
075B            396   ;        if p2Score == 5 , ljmp P2_Wins
075B            397   ;                
075B            398   
075B            399   P1_Wins:
075B            400   ; Display some sort of message
075B            401   
075B            402   P2_Wins:
075B            403   ; display some sort of message
075B            404   ;
075B            405   Play_Music:
075B            406   
075B            407   
075B            408   
075B            409   end
